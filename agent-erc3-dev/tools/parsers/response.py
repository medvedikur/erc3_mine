"""
Response tool parsers.
"""
from typing import Any
from erc3.erc3 import client
from ..registry import ToolParser, ParseContext
from ..links import LinkExtractor


@ToolParser.register("respond", "answer", "reply")
def _parse_respond(ctx: ParseContext) -> Any:
    """Submit final response to user."""
    args = ctx.args
    link_extractor = LinkExtractor()

    # Extract query_specificity
    query_specificity = (args.get("query_specificity") or args.get("querySpecificity") or
                         args.get("specificity") or "unspecified")
    if isinstance(query_specificity, str):
        query_specificity = query_specificity.lower().strip()
    if ctx.context and hasattr(ctx.context, 'shared'):
        ctx.context.shared['query_specificity'] = query_specificity

    # Extract message
    message = (args.get("message") or args.get("Message") or
               args.get("text") or args.get("Text") or
               args.get("response") or args.get("Response") or
               args.get("answer") or args.get("Answer") or
               args.get("content") or args.get("Content") or
               args.get("details") or args.get("Details") or
               args.get("body") or args.get("Body"))

    # FALLBACK: If agent mistakenly put message content in query_specificity, use it
    if not message:
        qs_value = args.get("query_specificity") or args.get("querySpecificity")
        if qs_value and isinstance(qs_value, str) and len(qs_value) > 50:
            # Likely a message mistakenly put in query_specificity
            message = qs_value
        else:
            message = "No message provided."

    # Extract/infer outcome
    outcome = args.get("outcome") or args.get("Outcome")
    if not outcome:
        msg_lower = str(message).lower()
        if "cannot" in msg_lower or "unable to" in msg_lower or "could not" in msg_lower:
            if "tool" in msg_lower or "system" in msg_lower:
                outcome = "none_unsupported"
            elif any(w in msg_lower for w in ["permission", "access", "allow", "restricted"]):
                outcome = "denied_security"
            else:
                outcome = "none_clarification_needed"
        else:
            outcome = "ok_answer"

    # Extract and normalize links
    raw_links = args.get("links") or args.get("Links") or []
    links = link_extractor.normalize_links(raw_links)

    # Auto-detect links from message
    if not links:
        links = link_extractor.extract_from_message(str(message))

    # Validate employee links
    if links and ctx.context:
        links = link_extractor.validate_employee_links(links, ctx.context.api)

    # Add mutation/search entities
    if ctx.context:
        had_mutations = ctx.context.shared.get('had_mutations', False)
        mutation_entities = ctx.context.shared.get('mutation_entities', [])
        search_entities = ctx.context.shared.get('search_entities', [])

        if had_mutations:
            links = link_extractor.add_mutation_entities(links, mutation_entities, ctx.current_user)
        elif search_entities:
            # Always add search entities if available - ensures links are present even with empty message
            links = link_extractor.add_search_entities(links, search_entities)

    # Deduplicate
    links = link_extractor.deduplicate(links)

    # Clear links for error/denied outcomes
    if outcome in ("error_internal", "denied_security"):
        links = []

    return client.Req_ProvideAgentResponse(
        message=str(message),
        outcome=outcome,
        links=links
    )
